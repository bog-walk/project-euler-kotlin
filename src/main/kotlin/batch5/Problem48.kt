package batch5

import java.math.BigInteger

/**
 * Problem 48: Self Powers
 *
 * https://projecteuler.net/problem=48
 *
 * Goal: Find the last 10 digits of the number generated by the
 * series, 1^1 + 2^2 + 3^3 + .. + N^N, without leading zeroes.
 *
 * Constraints: 1 <= N <= 2e6
 *
 * e.g.: N = 10
 *       1^1 + 2^2 + 3^3 + .. + 10^10 = 10405071317
 *       last 10 digits = 405071317 (leading zero omitted)
 */

class SelfPowers {
    // Long.MAX_VALUE is 19 digits long
    private val modulo: Long = 10_000_000_000

    /**
     * Solution uses BigInteger, due to exponential growth of
     * sum, and its built-in modPow(exp, mod).
     *
     * SPEED (BETTER): 0.7089s for N = 1e5
     */
    fun selfPowersSum(n: Int): Long  {
        val bigMod = this.modulo.toBigInteger()
        var sum = BigInteger.ZERO
        for (d in 1..n) {
            val power = d.toBigInteger()
            sum += power.modPow(power, bigMod)
        }
        return sum.mod(bigMod).toLong()
    }

    /**
     * Alternative solution based on the rule that:
     * (x + y) % z == ((x % z) + (y % z)) % z.
     * This same rule applies to multiplication with modulo.
     * The carried over number for each new self-power is thereby
     * significantly reduced by performing modulo at every step, which
     * avoids need for the use of BigInteger.
     *
     * SPEED: 63.8499s for N = 1e5
     */
    fun selfPowersSumModulo(n: Int): Long {
        var sum = 0L
        for (d in 1..n) {
            var power = d.toLong()
            repeat(d - 1) {
                power *= d
                power %= this.modulo
            }
            sum += power
            sum %= this.modulo
        }
        return sum
    }
}